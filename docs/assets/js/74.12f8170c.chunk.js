(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{494:function(n,e,t){"use strict";t.r(e),e.default="const workerScript = `\nonmessage = e => {\n  const canvas = e.data.canvas\n  main(canvas);\n}\n\nasync function main(canvas) {\n    canvas.width = canvas.height = 500;\n    canvas.style = 'width:500px;height:500px';\n    const adapter = await navigator.gpu.requestAdapter();\n    const device = await adapter.requestDevice();\n\n    const vs = \\`\n        struct VertexOutput {\n          @builtin(position) position : vec4<f32>\n        };\n\n        @vertex\n        fn main(@location(0) a_position : vec2<f32>) -> VertexOutput {\n          var output : VertexOutput;\n          output.position = vec4<f32>(a_position, 0.0, 1.0);\n          return output;\n        }\n    \\`;\n\n    const fs = \\`\n        @fragment\n        fn main() -> @location(0) vec4<f32> {\n          return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n        }\n    \\`;\n\n    const context = canvas.getContext('webgpu');\n\n    const swapChainFormat = navigator.gpu.getPreferredCanvasFormat();\n    const swapChain = context.configure({\n        device,\n        format: swapChainFormat,\n        alphaMode: \"opaque\",\n    });\n\n    const verticesData = new Float32Array([\n        0, 0.8,\n        -0.8, -0.8,\n        0.8, -0.8,\n    ]);\n    const verticesBuffer = device.createBuffer({\n        size: verticesData.byteLength,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true\n    });\n    new Float32Array(verticesBuffer.getMappedRange()).set(verticesData);\n    verticesBuffer.unmap();\n\n    const pipeline = device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n            module: device.createShaderModule({\n                code: vs\n            }),\n            entryPoint: 'main',\n            buffers:[{\n                arrayStride: 2 * 4,\n                attributes:[{\n                    shaderLocation: 0,\n                    offset: 0,\n                    format: 'float32x2'\n                }]\n            }]\n        },\n        fragment: {\n            module: device.createShaderModule({\n                code: fs\n            }),\n            entryPoint: 'main',\n            targets:[{\n                format: swapChainFormat\n            }],\n        },\n        primitive:{\n            topology: 'triangle-list'\n        },\n    });\n\n    function render() {\n        const commandEncoder = device.createCommandEncoder({});\n        const textureView = context.getCurrentTexture().createView();\n\n        const renderPassDescriptor = {\n            colorAttachments: [{\n                view: textureView,\n                loadOp: 'clear',\n                storeOp: 'store',\n                clearValue:{\n                    r: 0,\n                    g: 0,\n                    b: 0,\n                    a: 1,\n                }\n            }],\n        };    \n\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setVertexBuffer(0, verticesBuffer);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n\n        device.queue.submit([commandEncoder.finish()]);\n    }\n\n    render();\n}\n`;\n\nlet blob = new Blob([workerScript], {type: 'text/plain'});\nconst workerUrl = URL.createObjectURL(blob);\n\nconst offscreen = document.querySelector('canvas').transferControlToOffscreen();\nconst worker = new Worker(workerUrl);\nworker.postMessage({ canvas: offscreen }, [offscreen]);"}}]);